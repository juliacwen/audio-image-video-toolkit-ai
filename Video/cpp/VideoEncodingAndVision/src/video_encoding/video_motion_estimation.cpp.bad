/******************************************************************************
 * File: video_motion_estimation.cpp
 * Description:
 *   Capture from camera, compute dense optical flow (Farneback),
 *   print representative motion statistics and write frames
 *   with motion-vector overlay to an MJPG/AVI file.
 *   Centralized logging, constants, Ctrl-C support.
 *
 * Author: Julia Wen wendigilane@gmail.com
 * Date: 2025-09-05
 ******************************************************************************/

#include "../video_common/inc/video_common.h"
#include <opencv2/opencv.hpp>
#include <cmath>
#include <iostream>

int main(int argc, char** argv) {
    // Parse -v argument for logging level
    for (int i = 1; i < argc; ++i) {
        if (std::string(argv[i]) == "-v" && i + 1 < argc) {
            int lvl = std::stoi(argv[i + 1]);
            if (lvl >= static_cast<int>(LogLevel::INFO) && lvl <= static_cast<int>(LogLevel::ERROR)) {
                logLevel = static_cast<LogLevel>(lvl);
            }
        }
    }

    // Register Ctrl-C
    std::signal(SIGINT, handleSigInt);

    LOG(LogLevel::INFO, "=== Video Motion Estimation ===");
    LOG(LogLevel::INFO, "Logging level: " << static_cast<int>(logLevel));

    // Open camera
    cv::VideoCapture cap(0);
    if (!cap.isOpened()) {
        LOG(LogLevel::ERROR, "Cannot open camera.");
        return -1;
    }
    LOG(LogLevel::INFO, "Camera opened.");

    cv::Mat prevFrame, prevGray;
    cap >> prevFrame;
    if (prevFrame.empty()) {
        LOG(LogLevel::ERROR, "Empty frame captured.");
        return -1;
    }
    cv::cvtColor(prevFrame, prevGray, cv::COLOR_BGR2GRAY);

    // Video writer
    const std::string outFile = "output_video.avi";
    cv::VideoWriter writer(outFile,
                           cv::VideoWriter::fourcc('M','J','P','G'),
                           VIDEO_FPS,
                           prevFrame.size());
    if (!writer.isOpened()) {
        LOG(LogLevel::ERROR, "Could not open video file for writing.");
        return -1;
    }
    LOG(LogLevel::INFO, "Writing to: " << outFile);

    cv::Mat currFrame, currGray;
    int frameCount = 0;

    while (!stopFlag) {
        cap >> currFrame;
        if (currFrame.empty()) {
            LOG(LogLevel::WARNING, "Empty frame captured at frame " << frameCount << ". Skipping.");
            continue;
        }

        cv::cvtColor(currFrame, currGray, cv::COLOR_BGR2GRAY);

        // Compute dense optical flow
        cv::Mat flow = computeVideoMotionField(prevGray, currGray);

        cv::Mat display = currFrame.clone();
        cv::Mat displayScaled;
        cv::resize(display, displayScaled, cv::Size(), WINDOW_SCALE, WINDOW_SCALE);

        for (int y = 0; y < display.rows; y += DISPLAY_STEP) {
            for (int x = 0; x < display.cols; x += DISPLAY_STEP) {
                const cv::Point2f& fxy = flow.at<cv::Point2f>(y, x);
                float magnitude = std::sqrt(fxy.x*fxy.x + fxy.y*fxy.y);
                cv::Scalar color = (magnitude > HIGHLIGHT_THRESHOLD) ? STRONG_COLOR : NORMAL_COLOR;
                cv::line(display, cv::Point(x,y),
                         cv::Point(cvRound(x + fxy.x * VECTOR_SCALE), cvRound(y + fxy.y * VECTOR_SCALE)),
                         color, 2);
                cv::circle(display, cv::Point(x,y), REF_POINT_RADIUS, REF_COLOR, -1);
            }
        }

        // Debug log for reference points
        for (const auto &pt : DEBUG_POINTS) {
            const cv::Point2f &f = flow.at<cv::Point2f>(pt.y, pt.x);
            LOG(LogLevel::INFO, "Frame " << frameCount << " motion(" << pt.x << "," << pt.y << "): dx=" << f.x << ", dy=" << f.y);
        }

        cv::imshow("Motion Vectors Full", display);
        cv::imshow("Motion Vectors Scaled", displayScaled);
        writer.write(display);

        prevGray = currGray.clone();
        frameCount++;

        // Exit on ESC
        if (cv::waitKey(1) == KEY_EXIT_ESC) break;
    }

    cap.release();
    writer.release();
    cv::destroyAllWindows();
    LOG(LogLevel::INFO, "Video capture and writing completed: " << outFile);

    return 0;
}

